# 01. è®¤è¯†æ—¶é—´å¤æ‚åº¦ã€ç®€å•æ’åº

### ä»€ä¹ˆæ˜¯æ—¶é—´å¤æ‚åº¦ï¼Ÿ

- **to measure the performance of constant operations** 

#### å¸¸æ•°æ“ä½œ

1. Arithmetic operations: +, -, *, /, %, //, **
2. Bitwise operations: &, |, ^, ~, <<, >>
3. Boolean operations: and, or, not
4. Comparison operations: <, <=, >, >=, ==, !=
5. Identity operations: is, is not
6. Membership operations: in, not in
7. etc.
8. ä¸æ•°æ®é‡æ— å…³çš„æ“ä½œ

#### éå¸¸æ•°æ“ä½œ

e.g. 
1. fetch [i] in a linked list 

## ç­‰å·®æ•°åˆ— ï¼ˆæ±‚å‰né¡¹å’Œï¼‰

- å·²çŸ¥é¦–é€‰ã€æœ«é¡¹ã€é¡¹æ•°ï¼Œæ±‚å’Œ ï¼ˆå€’åºç›¸åŠ æ³•ï¼‰
$S_n = \frac{n \times (a_1 + a_2)}{2}$ 
- å·²çŸ¥é¦–é¡¹ã€é¡¹æ•°ã€å…¬å·®ï¼Œæ±‚å’Œ
$S_n = a_1 \times n + \frac{n \times (n-1)}{2} \times d$

## é€‰æ‹©æ’åº

- åŸºæœ¬æ€æƒ³ï¼šåœ¨æ¯æ¬¡è¿­ä»£ä¸­æ‰¾åˆ°å‰©ä½™æœªæ’åºéƒ¨åˆ†çš„æœ€å°å…ƒç´ ,å¹¶å°†å…¶æ”¾åˆ°æ­£ç¡®çš„ä½ç½®ã€‚
- æ­¥éª¤
  - works by repeatedly finding the smallest element in an array and swapping it with the first element in the array.
  2. starts at the beginning of the array and compares the first element with the remaining elements in the array. The smallest element is found and swapped with the first element.
  3. then moves on to the next element and repeats the process. This continues until the end of the array is reached.

### ä»£ç 1

```python
# é”™è¯¯ç‰ˆæœ¬ï¼š
def selection_sort(arr):
    # rule out edge cases 
    if arr is None or len(arr) < 2:
        return arr
    # loop through the arr 
    i = 0
    j = 1
    while i < len(arr):
        # assume the min value is the first element
        min_index = i
        while j < len(arr):
            # any value less than the min value, update the min value
            if(arr[j] < arr[min_index]):
                # found new min value, update the min value
                min_index = j
                # swap the values 
                print('before swap: ', arr)
                arr[i], arr[j] = arr[j], arr[i]
                print('after swap:', arr)
            j += 1
        i += 1
    print(arr)

selection_sort([1, 3, 2, 5, 4])
```

#### ä»£ç 1çš„é”™è¯¯

1. ä¸åº”è¯¥åœ¨å¾ªç¯ä¸­äº¤æ¢å€¼ï¼›åº”è¯¥åšçš„æ˜¯æ›´æ–°min_indexçš„ä½ç½®
2. jæŒ‡é’ˆåº”è¯¥åº”è¯¥å§‹ç»ˆå’Œmin_indexæœ‰å…³ï¼Œå³æ˜¯min_i_dexçš„åä¸€ä½ï¼ˆæœ€å°å€¼çš„ä¸‹ä¸€ä½ï¼‰ï¼Œæ‰€ä»¥ä¸èƒ½åˆå§‹1åå† +=1

### ä»£ç 2

```python
# æ­£ç¡®çš„å†™æ³•
def selectionSort(arr):
    for i in range(len(arr) - 1):
        #è®°å½•æœ€å°æ•°çš„ç´¢å¼•
        minIndex = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
        # i ä¸æ˜¯æœ€å°æ•°æ—¶ï¼Œå°† i å’Œæœ€å°æ•°è¿›è¡Œäº¤æ¢
        if i != minIndex:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
    return arr
```

1. æ’åºå­æ•°ç»„çš„èŒƒå›´ ï¼š 0 ~ len - 1
2. å› ä¸ºæœ€åä¸€ä¸ªå­æ•°ç»„ä¸€å®šæ˜¯æœ€å¤§çš„ï¼Œä¸éœ€è¦æ’åºï¼ˆå‰é¢å·²ç»æ’å®Œäº†ï¼‰
3. å­å¾ªç¯ä¸­ j æ˜¯é”å®š minIndex
4. pythonä¸­éœ€è¦å†å¾ªç¯å¤–è°ƒæ¢å…ƒç´ å€¼

## å†’æ³¡æ’åº

1. ä»index-0å¼€å§‹ï¼Œå¯¹æ¯”0,1ä¸Šçš„å…ƒç´ å¤§å°ï¼Œå¦‚1<0åˆ™äº¤æ¢
2. ä¾æ¬¡ç±»æ¨ï¼Œå¯¹æ¯”1,2; 2,3 ...
3. ç¬¬ä¸€æ¬¡å¾ªç¯ç»“æŸï¼Œå°±å¯ä»¥ç¡®å®š**æœ€åä¸€ä¸ªå…ƒç´ **åœ¨æ­£ç¡®çš„ä½ç½®ä¸Š
4. ä»¥æ­¤ç±»æ¨ï¼Œç¡®å®šå€’æ•°2ï¼Œ3 ...

### æ—¶é—´å¤æ‚åº¦

$O(N^2)$

### ä»£ç 

```python
def bubble_sort(arr):
    # edge cases
    if arr is None or len(arr) < 2:
        return arr
    """
    Because buble sort confirms the largest element at the end of the array in each sort loop, we need to slice out the last element for the next loop.
    """
    for i in range(len(arr), 0, -1):
        for x in range(0,i-1): # i is the length of the sliced array
            # if the current element is greater than the next element, swap them
            if arr[x] > arr[x+1]:
                print('\nbefore swap: ', arr)
                print("We are going to swap {} with {} at the index of {} and {}".format(arr[x], arr[x+1],x, x+1))
                arr[x], arr[x+1] = arr[x+1], arr[x]
                print('after swap: ', arr)
    print('\nğŸ˜ Bubble sort completed: ', arr)
    
bubble_sort([7, 5, 3, 2, 4])
```

## å¼‚æˆ–è¿ç®—

1. å¯ä»¥ç†è§£ä¸º*æ— è¿›ä½ç›¸åŠ *
2. æ€§è´¨ï¼š
    1. ä»»ä½•æ•°Nå’Œ0å¼‚æˆ–ï¼Œç»“æœä¸ºN
    2. ä»»ä½•æ•°Nå’Œè‡ªå·±å¼‚æˆ–ï¼Œç»“æœä¸º0
    3. äº¤æ¢å¾‹ï¼šç¡®å®ï¼Œå¼‚æˆ–æ“ä½œéµå¾ªäº¤æ¢å¾‹ï¼Œå³ aâŠ•b=bâŠ•aaâŠ•b=bâŠ•aã€‚
    4. ç»“åˆå¾‹ï¼šå¼‚æˆ–æ“ä½œä¹Ÿéµå¾ªç»“åˆå¾‹ï¼Œå³ aâŠ•(bâŠ•c)=(aâŠ•b)âŠ•caâŠ•(bâŠ•c)=(aâŠ•b)âŠ•cã€‚
    5. åˆ†é…å¾‹ï¼šå¼‚æˆ–æ“ä½œä¸éµå¾ªåˆ†é…å¾‹ã€‚åœ¨å¸ƒå°”ä»£æ•°ä¸­ï¼Œåˆ†é…å¾‹é€šå¸¸æŒ‡çš„æ˜¯ä¸ï¼ˆANDï¼‰å’Œæˆ–ï¼ˆORï¼‰æ“ä½œã€‚å¼‚æˆ–æ“ä½œçš„åˆ†é…å¾‹å½¢å¼ aâŠ•(bâŠ•c)=(aâŠ•b)âŠ•(aâŠ•c)aâŠ•(bâŠ•c)=(aâŠ•b)âŠ•(aâŠ•c) å¹¶ä¸æˆç«‹ã€‚

### 2ä¸ªä»¥ä¸Šæ•°å­—çš„å¼‚æˆ–è¿ç®—

- å…ˆåé¡ºåºä¸ä¼šæœ‰ä»»ä½•å½±å“

### ä¾‹1 - äº¤æ¢a, bä¸¤æ•°çš„å€¼

1. a = a^b
2. b = a^b ç”±äºåœ¨(1)ä¸­ï¼Œaæœ‰é‡æ–°èµ‹å€¼ï¼Œå› æ­¤ $b_2$= a^b^b = a
3. a = a^b åŒç†ï¼Œç”±äº(1)(2)ä¸­å¯¹a,béƒ½æœ‰é‡æ–°èµ‹å€¼ï¼Œå› æ­¤ $a_3$ = a^b^a = b

- *æ³¨æ„: a,bå¿…é¡»æŒ‡å‘å†…å­˜ä¸­çš„ä¸åŒåœ°å€* 
- ä¾‹å¦‚ï¼Œåœ¨æ•°ç»„ä¸­è°ƒæ¢arr[i] arr[j]çš„å€¼ï¼Œå¿…é¡»ç¡®ä¿i!=jã€‚å¦åˆ™XORè°ƒæ¢åï¼Œæœ€åè¿™ä½ç½®ä¸Šçš„æ•°ä¼šä¸º0

#### ä»£ç 

```python
a = '10110'
b = '00111'
# convert binary strings to integers
a_int = int(a, 2)
b_int = int(b, 2)

# bitwise XOR
result = a_int ^ b_int

print(bin(result)[2:])  # convert result back to binary string

# 10001
```

### ä¾‹2 - äº¤æ¢å¾‹ã€ ç»“åˆå¾‹

1. å‡å°‘ç©ºé—´ä½¿ç”¨
2. å‰æï¼š A, B åœ¨å†…å­˜ç©ºé—´ä¸­æ˜¯å„è‡ªç‹¬ç«‹çš„ã€‚å¦‚æœä¸æ˜¯ï¼Œæœ€åç»“æœä¼šæ˜¯0ã€‚

#### ä»£ç 

```python
# commtativity & associativity 
# å‡è®¾ A = ç”²ï¼Œ B = ä¹™
A = 17
B = 23
A = A^B # æ–°A = ç”² ^ ä¹™
print(A)
B = A^B # æ–°B = ç”² ^ ä¹™ ^ ä¹™ ï¼› æ ¹æ®äº¤æ¢ç»“åˆå¾‹ , å¾— ç”²^(ä¹™^ä¹™) = ç”²
print(B)
A = A^B  # æ–°A = ç”² ^ ä¹™ ^ ç”² = ä¹™
print(A)
```

### ä¾‹3 - å¯»æ‰¾å”¯ä¸€ä¸æˆå¯¹çš„æ•°

1. æœ‰ä¸€ä¸ªæ­£æ•°æ•°ç»„ arr[int]
2. å…¶ä¸­æœ‰ä¸€ä¸ªæ•°å‡ºç°äº†å¥‡æ•°æ¬¡ï¼Œå…¶ä»–æ•°å‡ºç°å¶æ•°æ¬¡ï¼Œè¯·é—®è¿™ä¸ªå¥‡æ•°æ¬¡çš„æ•°æ˜¯ä»€ä¹ˆï¼Ÿ
    - ç”¨å¼‚æˆ–è¿ç®—æ¶ˆæ¶ˆä¹
3. æœ‰ä¸¤ä¸ªæ•°å‡ºç°äº†å¥‡æ•°æ¬¡ï¼Œå…¶ä»–æ•°å‡å‡ºç°å¶æ•°æ¬¡ï¼Œè¯·é—®è¿™ä¸¤ä¸ªæ•°æ˜¯ä»€ä¹ˆï¼Ÿ
4. è¦æ±‚æ—¶é—´å¤æ‚åº¦æ˜¯O(n)

#### ä»£ç 

```python
def printOddNum1(arr):
    eor = 0
    for element in arr:
        eor ^= element
    return eor 

print(printOddNum1([1,1,1,2,3,3,2]))
```

### ä¾‹4 - å¯»æ‰¾å”¯äºŒä¸æˆå¯¹çš„æ•°

- æœ‰ä¸¤ä¸ªæ•°å‡ºç°äº†å¥‡æ•°æ¬¡ï¼Œå…¶ä»–æ•°å‡å‡ºç°å¶æ•°æ¬¡ï¼Œè¯·é—®è¿™ä¸¤ä¸ªæ•°æ˜¯ä»€ä¹ˆï¼Ÿ
1. é‡å¤[2]çš„æ­¥éª¤ï¼Œè·å¾—EOR = a ^ b ï¼ˆä¸¤ä¸ªå¥‡æ•°çš„å¼‚æˆ–ç»“æœï¼‰ 
2. å·²çŸ¥a !=b (å¦‚æœç›¸ç­‰ï¼Œé‚£ä¹ˆeor = 0)ï¼Œå› æ­¤EORè¿™ä¸ªç»“æœä¸­ï¼Œè‡³å°‘æœ‰ä¸€ä½æ˜¯1ã€‚å‡è®¾1æ˜¯åœ¨kä½ç½®ä¸Šã€‚
3. å†æ¬¡éå†æ‰€æœ‰çš„æ•°å­—ï¼Œå¹¶åªå¯¹æ‰€æœ‰kä½ç½®ä¸Šæ˜¯1çš„æ•°å­—è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼ˆä¹Ÿå¯é€‰æ‹©å¯¹Kä½ç½®ä¸Šæ˜¯0çš„æ•°å­—è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼‰ï¼Œå°†ç»“æœèµ‹å€¼ç»™ EOR'ã€‚
4. å¼‚æˆ–è®¡ç®— EOR ^ EOR'  = a ^ b ^ a = bã€‚è·å¾—2ä¸ªå¥‡æ•°ä¸­çš„ä¸€ä¸ªï¼Œå‡è®¾æ˜¯b
5. å°†è¿™ä¸ªæ•°å€¼ b ^ EOR = aã€‚è·å¾—å¦ä¸€ä¸ªçš„å¥‡æ•°

#### å°†äºŒè¿›åˆ¶æ•°çš„æœ€å³è¾¹çš„1å–å‡ºæ¥

```python
def get_rightest_one(n):
    return n & (~n + 1)
```
```
e.g: 
 EOR =              10101000
~EOR =              01010111
~EOR + 1 =          01011000
----------------------------
                        x     // æœ€å³è¾¹çš„1

EOR & (~EOR + 1) =  00001000  // &æŒ‰ä½ä¸ï¼Œåªæœ‰1&1=1ï¼Œå…¶ä»–éƒ½æ˜¯0
```

`~` å–åè¿ç®—
- åœ¨äºŒè¿›åˆ¶ä¸­,å°†æ¯ä¸ªä½ä¸Šçš„1å˜ä¸º0,0å˜ä¸º1 

`&` ä¸è¿ç®—
- 1 & 1 = 1 ï¼› å…¶ä»–æ•°å­—ç›¸ä¸éƒ½æ˜¯0

å…³äºâ€œè¡¥ç â€
- ä»»ä½•æ•´æ•°`n` çš„è¡¥ç éƒ½æ˜¯ `~n+1`
- è¿™æ˜¯å› ä¸º `n+(~n+1) = n-n+1-1 = 0`

#### ä»£ç 

```python
def printOddNum2(arr):
    EOR = 0
    for x in range(len(arr)):
        EOR ^= arr[x]
    print('ä¸¤ä¸ªå¥‡æ•°çš„å¼‚æˆ–ç»“æœ: {}, ç”¨äºŒè¿›åˆ¶è¡¨è¾¾å°±æ˜¯{} '.format(EOR, bin(EOR)[2:]))
    
    farRightOne = EOR & (~EOR + 1)
    
    onlyOne = 0 #å³eor'
    for x in range(len(arr)):
        # é€šè¿‡ä¸è¿ç®—ï¼Œæ‰¾åˆ°åœ¨kä½ç½®ä¸Šä¸º1çš„æ‰€æœ‰æ•°ï¼›å¹¶è¿›è¡Œå¼‚æˆ–è¿ç®—
        if (arr[x] & farRightOne == 0):  # ==0 çš„å¦‚æœæ˜¯a , é‚£ä¹ˆ ==1 çš„å°±æ˜¯b
            onlyOne ^= arr[x]
    print('å…¶ä¸­çš„ä¸€ä¸ªå¥‡æ•° :', onlyOne)
    print('åˆ™å¦ä¸€ä¸ªå¥‡æ•°æ˜¯ :', EOR ^ onlyOne)
    
printOddNum2([1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10]) # 9,10
```

## æ’å…¥æ’åº

å¤æ‚åº¦åˆ†æ

- Time Complexity: O(n^2)
- Space Complexity: O(1)

### ä¼ªä»£ç 

```python
     [3 ,2, 5, 4, 2, 3, 3]  
     ----------------------
      0  1  2  3  4  5  6
- 1st iteration [0] 
- 2nd iteration [0, 1] : arr[0] > arr[1] => swap => [2,3,5,4,2,3,3] 0~1æœ‰åº
- 3rd iteration [0, 1, 2] : arr[1] < arr[2] => no swap => [2,3,4,5,2,3,3] 0~2æœ‰åº
- 4th iteration [0, 1, 2, 3] : arr[2] < arr[3] => no swap => [2,3,4,5,2,3,3] 0~3æœ‰åº
- 5th iteration [0, 1, 2, 3, 4] : 
                                arr[3] > arr[4] => swap => [2,3,4,2,5,3,3] 0~4æœ‰åº? False 
                                arr[2] > arr[3] => swap => [2,3,2,4,5,3,3] ...
                                arr[1] > arr[2] => swap => [2,2,3,4,5,3,3] 0~4æœ‰åº

ä»¥æ­¤ç±»æ¨
```

### ä»£ç 

```python
def insertion_sort(arr):
    # edge cases 
    if arr is None or len(arr)<2:
        return arr 
    
    for i in range(1, len(arr)): # æ¯ä¸€æ­¥çš„ç›®æ ‡ï¼Œ0 ~ iä¸Šæœ‰åº
        print("\nç°åœ¨å¤„ç†çš„æ˜¯æ•°ç»„ä¸­çš„ä¸‹ä½ä»0 ~ {}çš„éƒ¨åˆ†ï¼Œå³{}".format(i,arr[:i+1]))
        
        for j in range(i-1, -1, -1): # ä»i-1å¼€å§‹ï¼Œå¾€å‰çœ‹ï¼Œå¦‚æœi-1å’Œiä¸æ»¡è¶³é¡ºåºï¼Œå°±äº¤æ¢ 
    
            # è¦ä¹ˆi-1å¼€å§‹ï¼Œå¯¹æ¯” j ,j +1 ï¼›é‚£ä¹ˆiå¼€å§‹ï¼Œå¯¹æ¯”j-1, j
            print("å¯¹æ¯”çš„æ˜¯{}å’Œ{}ä½ç½®ä¸Šçš„æ•°".format(j, j+1))
            
            if j>=0 and arr[j]>arr[j+1]:
                print("å‘ç°{}å’Œ{}ä½ç½®ä¸Šçš„æ•°ä¸æ»¡è¶³é¡ºåºï¼Œäº¤æ¢".format(j, j+1))
                print("äº¤æ¢å‰çš„æ•°ç»„æ˜¯{}".format(arr))
                arr[j], arr[j+1] = arr[j+1], arr[j]
                print("äº¤æ¢åçš„æ•°ç»„æ˜¯{}".format(arr))
            else:
                print("å‘ç°{}å’Œ{}ä½ç½®ä¸Šçš„æ•°æ»¡è¶³é¡ºåºï¼Œä¸äº¤æ¢".format(j, j+1))
    return arr 
```

## äºŒåˆ†æŸ¥æ‰¾

### ç”¨ä¾‹

1. æœ‰åºæ•°ç»„ä¸­ï¼Œæ‰¾æŸä¸ªæ•°æ˜¯å¦å­˜åœ¨ $O(log_{2}N)$
2. æœ‰åºæ•°ç»„ä¸­ï¼Œæ‰¾åˆ°>=æŸä¸ªæ•°æœ€å·¦ä¾§çš„ä½ç½® 
3. å±€éƒ¨æœ€å°å€¼é—®é¢˜ï¼Œè¿™æ—¶å€™å¯ä»¥æ˜¯æ— åºæ•°ç»„

### ä»£ç 

```python
def binarySearch(arr, target):
    left = 0
    right = len(arr) - 1
    
    while left <= right: # =æ¡ä»¶åŒ…æ‹¬åœ¨å†…ï¼Œç¡®ä¿æ•°ç»„åªåŒ…å«ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œè¿™ä¸ªç®—æ³•ä¹Ÿèƒ½æˆåŠŸ
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return True
        elif arr[mid] > target:
            right = mid - 1
        else:  # arr[mid] < target
            left = mid + 1
    
    return False  # å¦‚æœå¾ªç¯ç»“æŸä»æœªæ‰¾åˆ°ï¼Œåˆ™è¿”å›False

```

```python
a = [1,2,3,4,5,6,7,9,10]
b = 5
c = 8

print(binarySearch(a,b))
print(binarySearch(a,c))
```

### ä¾‹1 

ç”¨äºŒåˆ†æ³•æŸ¥æ‰¾åŒ…å«é‡å¤æ•°å­—çš„ã€æœ‰åºæ•°ç»„ä¸­ï¼Œå¤§äºç­‰äºç›®æ ‡æ•°ç»„æœ€å·¦ä½ç½®çš„å¯¹åº”æ•°å­—çš„ä¸‹æ ‡ï¼Œ å¦‚

- æ•°ç»„ [1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5,5] 
- æ‰¾åˆ° Target = 3 åœ¨ä»¥ä¸Šæ•°ç»„ä¸­æœ€å·¦ä¾§3çš„ä¸‹æ ‡
- ä¸æ™®é€šäºŒåˆ†æ³•çš„åŒºåˆ«æ˜¯ï¼Œè¿™ä¸ªæŸ¥æ‰¾å¿…é¡»è¦æ‰¾åˆ°æœ€åä¸€ä¸ªå…ƒç´ 
- ç±»ä¼¼ï¼Œä¹Ÿå¯ä»¥ç”¨æ¥å¯»æ‰¾å°äºç­‰äºç›®æ ‡æœ€å³ä¾§çš„æ•°å­—ä¸‹æ ‡

#### ä»£ç 

```python
def far_left_position(arr, target):
    left = 0
    right = len(arr) - 1
    t = -1  # å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¿”å›-1è¡¨ç¤ºä¸å­˜åœ¨

    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            t = mid # t= min(mid,t) è¿™æ˜¯å®‰å…¨ä¸”é€»è¾‘æ­£ç¡®ï¼Œä½†æ˜¯æ²¡æœ‰å¿…è¦çš„
            right = mid - 1  # ç»§ç»­å‘å·¦æœç´¢
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    if t == -1:
        print("The target number {} is not found in the array".format(target))
    else:
        print("The target number {} is located at index {} in the array".format(target, t))

```

### ç”¨äºŒåˆ†æ³•è§£å±€éƒ¨æœ€å°

é¢˜ç›®
1. åœ¨æ— åºæ•°ç»„ä¸­ï¼Œç›¸é‚»çš„æ•°å­—ä¸€å®šä¸ç›¸ç­‰ï¼Œæ‰¾åˆ°è¯¥æ•°ç»„ä¸­ä»»ä¸€ä¸€ä¸ªå±€éƒ¨æœ€å°æ•°å­—çš„ä¸‹æ ‡ï¼Œå¤æ‚åº¦ä¼˜äºO(N)
2. å±€éƒ¨æœ€å°çš„å®šä¹‰ï¼š
    1. å¦‚æœ arr[0] < arr[1] , arr[0]å°±æ˜¯å±€éƒ¨æœ€å°
    2. å¦‚æœ arr[n-1] < arr[n-2], arr[n]å°±æ˜¯å±€éƒ¨æœ€å°
    3. å¦‚æœ arr[n-k] < arr[n-k+1] ä¸” arr[n-k] < arr[n-k-1]ï¼Œ é‚£ä¹ˆarr[n-k]å°±æ˜¯å±€éƒ¨æœ€å°
3. æ— åºæ•°ç»„ä¸€å®šå­˜åœ¨â€œå±€éƒ¨æœ€å°â€

## å¯¹æ•°å™¨

- æœ‰ï¼šæ–¹æ³•A(æƒ³æµ‹è¯•çš„æ–¹æ³•ï¼‰ï¼›æ–¹æ³•B(æ˜¯ä¸è®¡è¾ƒä¼˜åŒ–çš„å¥½å®ç°çš„æ–¹æ³•ï¼‰
- éšæœºæ–¹æ³•äº§ç”Ÿå™¨ï¼šé€šè¿‡Aè·å¾—ç»“æœa ; B -> b 
- a ?= b

## `Math.random()` 

æ¦‚ç‡è¿”å›éšæœºæ•´æ•°

- random() => [0,1)æ‰€æœ‰å°æ•°ï¼Œç­‰æ¦‚ç‡è¿”å›ä¸€ä¸ª
- random() * N => [0, N) æ‰€æœ‰å°æ•°ï¼Œç­‰æ¦‚ç‡è¿”å›ä¸€ä¸ª
- int(random() * N) => [0, N-1] æ‰€æœ‰æ•´æ•°ï¼Œç­‰æ¦‚ç‡è¿”å›ä¸€ä¸ª

# 02. é€’å½’

## äºŒè¿›åˆ¶å³ç§»1ä½ = åŸæ•°é™¤ä»¥2

>  - mid = left + (right - left) // 2 
> - ç®€åŒ–ä¸º mid = L + (R-L) >> 1 *

åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ï¼Œæ¯ä¸ªæ•°å­—çš„ä½ç½®ä»£è¡¨ä¸€ä¸ªç‰¹å®šçš„å€¼ï¼Œè¿™ä¸ªå€¼æ˜¯2çš„å¹‚ã€‚ä»å³å‘å·¦çœ‹ï¼Œæœ€å³è¾¹çš„ä½ä»£è¡¨ `2^0`ï¼ˆå³1ï¼‰ï¼Œä¸‹ä¸€ä½ä»£è¡¨ `2^1`ï¼ˆå³2ï¼‰ï¼Œå†ä¸‹ä¸€ä½ä»£è¡¨ `2^2`ï¼ˆå³4ï¼‰ï¼Œä»¥æ­¤ç±»æ¨ã€‚

ä¾‹å¦‚ï¼ŒäºŒè¿›åˆ¶æ•° 1011 è¡¨ç¤ºä¸ºï¼š

    1Ã—23=81Ã—23=8
    0Ã—22=00Ã—22=0
    1Ã—21=21Ã—21=2
    1Ã—20=11Ã—20=1

æ‰€ä»¥ 1011 ç­‰äº 8+0+2+1=118+0+2+1=11ã€‚
å³ç§»æ“ä½œ

å³ç§»ä¸€ä½æ“ä½œï¼Œæ„å‘³ç€å°†äºŒè¿›åˆ¶æ•°ä¸­çš„æ¯ä¸€ä½éƒ½å‘å³ç§»åŠ¨ä¸€ä¸ªä½ç½®ã€‚è¿™ä¼šå¯¼è‡´æœ€å³è¾¹çš„ä¸€ä½è¢«ä¸¢å¼ƒï¼Œè€Œæœ€å·¦è¾¹ä¼šæ ¹æ®å…·ä½“çš„å³ç§»ç±»å‹ï¼ˆé€»è¾‘å³ç§»æˆ–ç®—æœ¯å³ç§»ï¼‰æ·»åŠ ä¸€ä½ï¼ˆé€šå¸¸æ˜¯0ï¼‰ã€‚åœ¨æ•°å€¼å±‚é¢ï¼Œè¿™ä¸ªæ“ä½œç›¸å½“äºå°†æ¯ä¸ªä½ä»£è¡¨çš„å€¼éƒ½å‡å°‘ä¸€åŠï¼ˆå› ä¸º 2n2n å˜æˆ 2nâˆ’12nâˆ’1ï¼‰ã€‚
ä¾‹å­

ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªäºŒè¿›åˆ¶æ•° 1100ï¼ˆåè¿›åˆ¶ä¸­çš„12ï¼‰ï¼š

    äºŒè¿›åˆ¶ 1100 è¡¨ç¤ºä¸ºï¼š
        1Ã—23=81Ã—23=8
        1Ã—22=41Ã—22=4
        0Ã—21=00Ã—21=0
        0Ã—20=00Ã—20=0
        æ€»å’Œ = 12
    
    å¦‚æœæˆ‘ä»¬å¯¹ 1100 è¿›è¡Œå³ç§»ä¸€ä½æ“ä½œï¼Œå¾—åˆ° 0110ï¼š
        0Ã—23=00Ã—23=0
        1Ã—22=41Ã—22=4
        1Ã—21=21Ã—21=2
        0Ã—20=00Ã—20=0
        æ€»å’Œ = 6

é€šè¿‡è¿™ä¸ªæ“ä½œï¼ŒåŸæ¥çš„å€¼12å˜æˆäº†6ï¼Œæ­£å¥½æ˜¯åŸå€¼çš„ä¸€åŠã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ï¼Œå³ç§»ä¸€ä½ç­‰åŒäºé™¤ä»¥2ã€‚

`2^n / 2 = 2^(n-1)`



## æ±‚æ•°ç»„ä¸­çš„æœ€å¤§å€¼

### Ver 1 

```python
def find_max(arr):
    # Base case: If the array has only one element, return that element
    if len(arr) == 1:
        return arr[0]

    # Recursive case: Find the maximum in the rest of the array
    max_of_rest = find_max(arr[1:])

    # Return the maximum of the first element and the maximum of the rest
    return max(arr[0], max_of_rest)

```

Consider an array [3, 1, 4, 2]. Here's how the process works:

- We want to find the max of [3, 1, 4, 2]. We compare 3 with the max of [1, 4, 2].
- To find the max of [1, 4, 2], we compare 1 with the max of [4, 2].
- To find the max of [4, 2], we compare 4 with the max of [2].
- The max of [2] is 2 (base case), so now we start comparing back up:
  - max(4, 2) = 4, so the max of [4, 2] is 4.
  - Then, max(1, 4) = 4, so the max of [1, 4, 2] is 4.
  - Finally, max(3, 4) = 4, so the max of [3, 1, 4, 2] is 4.

### Ver 2

```python
def find_max2(arr, l, r): # è¿™ä¸ªç¬¦åˆmasterå…¬å¼
    if l == r:
        return arr[l]
    
    mid = l + ((r-l)>>1)
    lMax = find_max2(arr, l, mid)
    rMax = find_max2(arr, mid+1, r)
    return max(lMax, rMax)
```

## Master å…¬å¼

- T(N) = a * T (N/b) + O(N^d)
    - T(N) æ¯é—®é¢˜çš„æ•°æ®é‡æ˜¯ N çº§åˆ«
    - T (N/b) æ‰€æœ‰å­é—®é¢˜çš„è§„æ¨¡éƒ½æ˜¯ N/b çº§åˆ« ï¼ˆå­é—®é¢˜è§„æ¨¡æ˜¯ç­‰é‡çš„ï¼‰
    - a å­é—®é¢˜è°ƒç”¨æ¬¡æ•°
    - O(N^d) é™¤å»å­é—®é¢˜è°ƒç”¨ä¹‹å¤–ï¼Œå‰©ä¸‹è¿‡ç¨‹çš„æ—¶é—´å¤æ‚åº¦

### Masterå…¬å¼ï¼šæ±‚é€’å½’æ—¶é—´å¤æ‚åº¦
- `find_max2`é€’å½’å‡½æ•°ç¬¦åˆMaster: a = 2, b =2 , d = 0
- n æ˜¯é€’å½’æ—¶å€™**å½“å‰çš„è§„æ¨¡**ï¼Œä¸éœ€è¦åœ¨ä¹æ¯ä¸€æ¬¡é€’å½’æ—¶å€™å®é™…nçš„å˜åŒ–

## å½’å¹¶æ’åº

**æ¦‚å¿µ**ï¼š
å½’å¹¶æ’åºæ˜¯ä¸€ç§é«˜æ•ˆçš„æ’åºç®—æ³•ï¼Œé‡‡ç”¨åˆ†æ²»æ³•ï¼ˆDivide and Conquerï¼‰ç­–ç•¥ã€‚å®ƒé€šè¿‡é€’å½’åœ°å°†åˆ—è¡¨åˆ†æˆä¸¤åŠï¼Œå¯¹æ¯åŠè¿›è¡Œæ’åºï¼Œç„¶åå°†æ’åºå¥½çš„ä¸¤åŠåˆå¹¶åœ¨ä¸€èµ·ã€‚

**æ ¸å¿ƒæ­¥éª¤**ï¼š

1. **åˆ†è§£**ï¼šå°†å¾…æ’åºæ•°ç»„åˆ†è§£æˆä¸¤ä¸ªå­æ•°ç»„çš„è¿‡ç¨‹ã€‚
2. **åˆå¹¶**ï¼šå°†ä¸¤ä¸ªæ’åºå¥½çš„å­æ•°ç»„åˆå¹¶æˆä¸€ä¸ªæœ€ç»ˆçš„æ’åºæ•°ç»„ã€‚

**åˆå¹¶æ“ä½œ**ï¼š
- ä½¿ç”¨åŒæŒ‡é’ˆæŠ€æœ¯æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å…ƒç´ ï¼Œå°†è¾ƒå°çš„å…ƒç´ å…ˆæ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­ã€‚
- å½“å…¶ä¸­ä¸€ä¸ªæ•°ç»„çš„å…ƒç´ å…¨éƒ¨è¢«é€‰å–åï¼Œå°†å¦ä¸€ä¸ªæ•°ç»„çš„å‰©ä½™å…ƒç´ ç›´æ¥è¿½åŠ åˆ°ç»“æœæ•°ç»„ä¸­ã€‚

**é€’å½’é€»è¾‘**ï¼š
- é€’å½’åœ°å¯¹æ•°ç»„è¿›è¡Œåˆ†åŠå¤„ç†ï¼Œç›´åˆ°æ•°ç»„é•¿åº¦å°äºæˆ–ç­‰äº1ï¼ˆè¿™æ˜¯åŸºå‡†æƒ…å†µï¼Œä¸éœ€è¦è¿›ä¸€æ­¥æ’åºï¼‰ã€‚
- ç„¶åé€’å½’åœ°å¯¹è¿™äº›åˆ†åŠåçš„æ•°ç»„è¿›è¡Œæ’åºå’Œåˆå¹¶ã€‚

**é‡è¦æ¦‚å¿µ**ï¼š
- **åŸºå‡†æƒ…å†µ**ï¼šé€’å½’å‡½æ•°çš„åœæ­¢æ¡ä»¶ï¼Œå¯¹äºå½’å¹¶æ’åºæ¥è¯´ï¼Œæ˜¯å½“å¤„ç†çš„æ•°ç»„é•¿åº¦å°äºæˆ–ç­‰äº1ã€‚
- **åˆ†è€Œæ²»ä¹‹**ï¼šå°†å¤§é—®é¢˜åˆ†è§£æˆå°é—®é¢˜è§£å†³ï¼Œç„¶åå°†å°é—®é¢˜çš„è§£å†³æ–¹æ¡ˆåˆå¹¶èµ·æ¥è§£å†³å¤§é—®é¢˜ã€‚

**ä»£ç å®ç°**ï¼š

```python
def merge(left, right):
    result = []  # æœ€ç»ˆçš„æ’åºç»“æœåˆ—è¡¨
    i, j = 0, 0  # åˆå§‹åŒ–ä¸¤ä¸ªåˆ—è¡¨çš„æŒ‡é’ˆ

    # å½“ä¸¤ä¸ªåˆ—è¡¨éƒ½æœ‰å…ƒç´ æ—¶
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # å°†å‰©ä½™å…ƒç´ è¿½åŠ åˆ°ç»“æœåˆ—è¡¨ä¸­
    result += left[i:]
    result += right[j:]

    return result


def merge_sort(arr):
    if len(arr) <= 1:
        return arr  # åŸºå‡†æƒ…å†µï¼Œç›´æ¥è¿”å›åˆ—è¡¨

    mid = len(arr) // 2  # æ‰¾åˆ°ä¸­é—´ç´¢å¼•
    left = merge_sort(arr[:mid])  # å¯¹å·¦åŠéƒ¨åˆ†é€’å½’æ’åº
    right = merge_sort(arr[mid:])  # å¯¹å³åŠéƒ¨åˆ†é€’å½’æ’åº

    return merge(left, right)  # åˆå¹¶ä¸¤ä¸ªæ’åºå¥½çš„å­åˆ—è¡¨

```

**é€’å½’è¿‡ç¨‹ç¤ºä¾‹**ï¼š
ä»¥æ•°ç»„ `[38, 27, 43, 3]` ä¸ºä¾‹ï¼Œå½’å¹¶æ’åºçš„è¿‡ç¨‹å¯ä»¥è¡¨ç¤ºä¸ºï¼š

```
          [38, 27, 43, 3]
             /       \
       [38, 27]     [43, 3]
        /   \         /   \
     [38]  [27]     [43]  [3]
        \   /         \   /
       [27, 38]     [3, 43]
             \       /
          [3, 27, 38, 43]
```

**ç†è§£é€’å½’**ï¼š
åœ¨æœ€é¡¶å±‚ï¼Œæ¯ä¸ªå­æ•°ç»„åªæœ‰å•ä¸€å…ƒç´ æ—¶ï¼Œåˆå¹¶æ“ä½œä¸»è¦å‘ç”Ÿåœ¨æ¯”è¾ƒè¿™äº›å•ä¸€å…ƒç´ å¹¶å°†å®ƒä»¬æŒ‰é¡ºåºåˆå¹¶çš„è¿‡ç¨‹ä¸­ã€‚è¿™ç¡®ä¿äº†æ¯ä¸€æ­¥åˆå¹¶éƒ½æ˜¯åœ¨æ„å»ºæ’åºå¥½çš„å­æ•°ç»„ï¼Œç›´åˆ°æœ€åæ‰€æœ‰å­æ•°ç»„åˆå¹¶æˆä¸€ä¸ªå®Œæ•´çš„æ’åºæ•°ç»„ã€‚

### ä»£ç 

```python
def merge(left, right):
    result = []  # æœ€ç»ˆçš„æ’åºç»“æœåˆ—è¡¨
    i, j = 0, 0  # åˆå§‹åŒ–ä¸¤ä¸ªåˆ—è¡¨çš„æŒ‡é’ˆ

    # å½“ä¸¤ä¸ªåˆ—è¡¨éƒ½æœ‰å…ƒç´ æ—¶
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # å°†å‰©ä½™å…ƒç´ è¿½åŠ åˆ°ç»“æœåˆ—è¡¨ä¸­
    result += left[i:]
    result += right[j:]

    return result


def merge_sort(arr):
    if len(arr) <= 1:
        return arr  # åŸºå‡†æƒ…å†µï¼Œç›´æ¥è¿”å›åˆ—è¡¨

    mid = len(arr) // 2  # æ‰¾åˆ°ä¸­é—´ç´¢å¼•
    left = merge_sort(arr[:mid])  # å¯¹å·¦åŠéƒ¨åˆ†é€’å½’æ’åº
    right = merge_sort(arr[mid:])  # å¯¹å³åŠéƒ¨åˆ†é€’å½’æ’åº

    return merge(left, right)  # åˆå¹¶ä¸¤ä¸ªæ’åºå¥½çš„å­åˆ—è¡¨

```

### å½’å¹¶æ’åºæ‰©å±•

#### å°å’Œé—®é¢˜
- åœ¨ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œæ¯ä¸€ä¸ªå·¦è¾¹æ¯”å½“å‰æ•°å°çš„æ•°ç´¯åŠ èµ·æ¥
- å¦‚ï¼š[1,3,4,2,5] 1å·¦è¾¹ä¸å­˜åœ¨>1çš„æ•°å­—ï¼›3å·¦è¾¹>3çš„æ•°å­—æœ‰ï¼š1ï¼›4å·¦è¾¹æœ‰ï¼š1,3;2å·¦è¾¹æœ‰ï¼š1ï¼›5å·¦è¾¹æœ‰ï¼š1,3,4,2
- æ‰€ä»¥å°å’Œç­‰äº `1+1+3+1+1+3+4+2 = 16`
